##11/17/2019
##@@author: Simon (Chong) Chu, DBMI, Harvard Medical School
##@@contact: chong_chu@hms.harvard.edu, chong.simon.chu@gmail.com

from l_rep_masker import *
import pysam
import global_values
from l_transduction import *
from x_annotation import *

###Todo-list: b_with_chr is set as "True" by default
###Bug: when there are supplementary, the "reference" are different, thus the position are not consistent!!!!!!!
###Bug: Several cases in "classified_results.txt.SVA.txt_to_be_decided_cases.txt" are L1, because aligned to flanking!!!!
####Hard code inside: b_with_chr is set to True by default !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

####The current version is align the contigs to SVA copies (with 3k extension at both ends)
####This is not the best way, as some copies myy have expansion happened, which will cause alignment clip
####    also, false positives will be called out when only aligned to flank regions with some "polyA" signal !!!!
####Write each assembled contig to one file, and then align the SVA pieces to each contig (algn to copy now)
####Separate the full mapped cases to:1. SVA retro-insertion. 2. SVA expansion (solved)
####

class SVAmasker(LRepMasker):
    def __init__(self, swfolder, n_jobs):#
        LRepMasker.__init__(self, swfolder, n_jobs)
        self.i_copy_flank_len=3000 #from repeatmasker output, we extend to both sides for 3000bp
        self.i_min_copy_len=500 #if longer than this one, flanks will be collected as polymorphic source
        self.i_chk_win = 150
        self.i_slack=75
        self.i_hit_right_least=100
        self._SVA = "SVA"
        self.min_sva_copy_len=75
        self.transdct = LTransduction(swfolder, n_jobs)

    def get_cns_copy_length(self, samfile):
        #samfile = pysam.AlignmentFile(sf_algnmt, "rb")  # read in the sam file
        t_references = samfile.references
        t_ref_lens = samfile.lengths
        m_refs = {}
        for (s_ref, i_ref_len) in zip(t_references, t_ref_lens):
            m_refs[s_ref] = i_ref_len
        return m_refs

    def get_flank_length(self):
        return self.i_copy_flank_len

    def construct_interval_tree(self, sf_rmsk, b_with_chr):
        xannotation = XAnnotation(sf_rmsk)
        #b_with_chr = True
        xannotation.set_with_chr(b_with_chr)
        xannotation.load_rmsk_annotation()
        xannotation.index_rmsk_annotation_interval_tree()
        return xannotation

####
    ###Assume the sf_algnmt is generated by aligning the contigs to the copies (with flanking regions) of same oritation
    def parse_SVA_from_algnmt(self, sf_algnmt, sf_rmsk, i_max_clip, sf_ref, sf_ref_fl_flank, flk_lenth, sf_out):#
        ###each record in format: t_segmt_pri, t_segmt_sup, algnmt, s_transduction_type, i_5mer_chk_len, i_3mer_chk_len
        ########t_segmt_pri in format (start, end, direction[+/-])
        l_transduct = []  # save the algnmts for further checking
        l_succeed = []
        l_ref_expansion=[]

        self.set_TSD(sf_ref)
        samfile = pysam.AlignmentFile(sf_algnmt, "rb")  # read in the sam file
        # t_references=samfile.references
        # t_ref_lens=samfile.lengths
        # m_refs={}
        # for (s_ref, i_ref_len) in zip(t_references, t_ref_lens):
        #     m_refs[s_ref]=i_ref_len
        m_refs=self.get_cns_copy_length(samfile)

        # xannotation = XAnnotation(sf_rmsk)
        # b_with_chr=True
        # xannotation.set_with_chr(b_with_chr)
        # xannotation.load_rmsk_annotation()
        # xannotation.index_rmsk_annotation_interval_tree()
####Hard code here!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        b_with_chr = True
        xannotation=self.construct_interval_tree(sf_rmsk, b_with_chr)
        xpolyA = PolyA()
        for algnmt in samfile.fetch():  # check each alignment
            if algnmt.is_secondary or algnmt.is_supplementary:  # filter out secondary and supplementary
                continue
            if algnmt.is_unmapped == True:  ##unmapped
                continue
            if algnmt.is_duplicate == True:  ##duplciation
                continue
                # if algnmt.mapping_quality<30:
                #     continue
                ####
            i_map_pos = algnmt.reference_start####
            i_max_all_clip = 2 * i_max_clip
            b_in_flank, b_fully_map, i_lclip, i_rclip = self.is_fully_map_with_flank(
                m_refs, algnmt, i_max_all_clip, self.i_copy_flank_len, self.i_slack)
            if b_in_flank==True:
                continue
####How to filter out the polyA only cases
            # if i_map_pos > self._polyA_start_pos:
            #     continue
####
            b_lclip = False
            b_rclip = False
            if i_lclip > i_max_clip:
                b_lclip = True
            if i_rclip > i_max_clip:
                b_rclip = True

            ####check the small clip region agains the flanking region for TSD
            ####some clip part are aligned, which will change b_lclip or b_rclip
            b_lclip, b_rclip = self.check_TSD_for_site(algnmt, i_lclip, i_rclip, b_lclip, b_rclip)
            l_cigar = algnmt.cigar
            if (b_fully_map == True) or ((b_lclip is False) and (b_rclip is False)):
                # m_fully_map[query_name] = query_seq
                i_seq_start = 0
                if l_cigar[0][0] == 4:
                    i_seq_start = l_cigar[0][1]

                i_map_end, n_mapped, i_seq_end = self._get_map_interval(l_cigar, i_map_pos)
                tmp_rcd = (i_map_pos, i_map_end, "+", i_seq_start, i_seq_end)
                if algnmt.is_reverse == True:
                    tmp_rcd = (i_map_pos, i_map_end, "-", i_seq_start, i_seq_end)
                rslt_rcd = self.get_ins_information_from_algnmt_ori_seq(algnmt, self._SVA, tmp_rcd, None)

                #whether this is within an reference SVA copy
                ins_chrm,ins_pos=self.get_ins_pos_from_query_name(algnmt)
                b_in_ref_sva, rep_start_pos = xannotation.is_within_repeat_region_interval_tree(ins_chrm, int(ins_pos))

                if b_in_ref_sva==False:
                    if self.hit_front_end_only(i_map_end)==True:#only hit front part
                        continue
                    if (i_map_end-i_map_pos) < self.min_sva_copy_len:
                        continue
                    l_succeed.append(rslt_rcd)
                elif (i_map_end-i_map_pos)>self.i_min_copy_len:
                    s_seq=rslt_rcd[8]
                    s_with_polyA = self.chk_polyA(xpolyA, s_seq)
                    if s_with_polyA == self._s_with_polyA:
                        l_succeed.append(rslt_rcd)
                    else:
                        l_ref_expansion.append((rep_start_pos, rslt_rcd))
                else:
                    l_ref_expansion.append((rep_start_pos, rslt_rcd))
            else:  # not fully mapped, and one side clipped then check
                ####if the aligned segment is no/with small overlap with the non-flanking region, than skip
                i_map_end, n_mapped, i_seq_end = self._get_map_interval(l_cigar, i_map_pos)
####
                ####collect transduction information, and also other fully mapped cases from Supplementary algnmt
                self.classify_with_supplementary_algnmt(algnmt, b_lclip, b_rclip, self._SVA, l_transduct, l_succeed)
        samfile.close()
        self.clean_TSD()#close the opened reference genome

        sf_rslts_non_transduction = sf_out + "_non_transduction.txt"
        self.save_non_transduct_ins_info_to_file_sva(l_succeed, global_values.LRD_MIN_INTERNAL_DEL,
                                                 sf_rslts_non_transduction, self.i_copy_flank_len)
        sf_rslts_in_ref_sva = sf_out + "_non_transduction_within_rep_copy.txt"
        self.save_expn_ref_ins_info_to_file(l_ref_expansion, global_values.LRD_MIN_INTERNAL_DEL, sf_rslts_in_ref_sva)

        sf_rslts = sf_out + "_transductions.txt"
        m_candidates, m_with_polya, m_transduct_tsd, m_tbd = self.transdct.call_transduction_from_candidates(
            l_transduct, l_succeed, self.i_min_copy_len, self.i_chk_win, flk_lenth, sf_ref, sf_ref_fl_flank)
        ########
        # print l_transduct
        # print m_candidates
        ########
        # merge the transduction tsd records to existing ones
        for s_tsd_id in m_transduct_tsd:
            if s_tsd_id in self.m_tsd:
                print("May Error: {0} TSD already exists".format(s_tsd_id))
            else:
                self.m_tsd[s_tsd_id] = m_transduct_tsd[s_tsd_id]
        m_not_slct = self.slct_save_transduction_to_file(l_transduct, m_candidates, m_with_polya, self._SVA, sf_rslts)
        self.merge_outputs(sf_rslts_non_transduction, sf_rslts, sf_out)

        # to-be-decided cases
        ####save the m_tbd records to file
        ####save the m_not_slct to file
        sf_rslts_tbd = sf_out + "_to_be_decided_cases.txt"
        self.save_tbd_cases_to_file(m_not_slct, sf_rslts_tbd)
####
####
####Potential bug here: if this is a reverse complementary, then it's not correct!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    def hit_front_end_only(self, i_map_end):
        b_hit_fron_only=False
        if i_map_end < (self.i_copy_flank_len + self.i_hit_right_least):
            b_hit_fron_only=True
        return b_hit_fron_only
    #here we need to pick out those transduction events

    ####save the non transduction inseriton events to a file
    ####each record in format:
    # ins_chrm, ins_pos, rep_type, structure_type, s_region1, s_region2, TSD, transduct_src, s_seq, transduct_seq
    ####i_del_slack: if the interval distance > i_del_slack, then view as an internal insertion
    def save_ins_info_to_file(self, l_succeed, i_del_slack, sf_out):
        with open(sf_out, "w") as fout_ins:
            lis = LInternalStructure()
            xpolyA=PolyA()
            for rcd in l_succeed:
                s_rg1=rcd[4]#region1
                s_rg2=rcd[5]#region2

                (ins_chrm, ins_pos, rep_type, structure_type, s_region1, s_region2, s_TSD, transduct_src,
                 s_seq, transduct_seq)=rcd
                s_structure=lis.get_internal_structure(s_rg1, s_rg2, i_del_slack)
                s_with_polyA = self.chk_polyA(xpolyA, s_seq)
                # b_rpolyA=xpolyA.is_consecutive_polyA_T(seq[:10])
                # b_lpolyA=xpolyA.is_consecutive_polyA_T(seq[-10:])
                # if b_lpolyA or b_rpolyA:
                #     s_with_polyA="with_polyA"
                s_id = "{0}~{1}".format(ins_chrm, ins_pos)
                if s_id in self.m_tsd:
                    s_TSD=self.m_tsd[s_id]
                sinfo = ins_chrm + "\t" + str(
                    ins_pos) + "\t" + rep_type + "\t" + s_structure + "\t" + s_region1 + "\t" + s_region2 + "\t" + \
                        s_TSD + "\t" + transduct_src + "\t" + transduct_src + "\t" + s_seq + "\t" + transduct_seq + \
                        "\t" + transduct_seq + "\t" + s_with_polyA + "\n"
                fout_ins.write(sinfo)
####
    ####check whether it is fully mapped
    ####If both side are fully mapped, then save to "l_both_transduct"
    def is_fully_map_with_flank(self, m_refs, algnmt, i_max_clip_len, i_flank_len, i_slack):
        l_cigar = algnmt.cigar
        b_flank = False
        if l_cigar[0][0]==5 or l_cigar[-1][0]==5:#hard clipped are not considered
            b_flank=True

        n_lclip = 0
        n_rclip = 0
        if l_cigar[0][0] == 4:  # left-clip
            n_lclip = l_cigar[0][1]
        if l_cigar[-1][0] == 4:  # right clipped
            n_rclip = l_cigar[-1][1]

        if l_cigar[0][0] == 5 and l_cigar[-1][0] == 5:#both side hard clip
            return False, l_cigar[0][1], l_cigar[-1][1]

        i_map_pos = algnmt.reference_start  ####
        i_seq_len=len(algnmt.query_sequence)
        i_map_end=i_map_pos+(i_seq_len-n_lclip-n_rclip)

        s_ref_name=algnmt.reference_name
        i_ref_len=0
        if s_ref_name in m_refs:
            i_ref_len=m_refs[s_ref_name]
        i_rflank_start=i_ref_len-i_flank_len
        i_rflank_end=i_ref_len
        #######################################
#chrX~101542039~0 3900 5433 3838 6838
        if (i_map_pos<i_flank_len) and (i_map_end<i_flank_len or abs(i_map_end-i_flank_len)<i_slack):
            print(algnmt.query_name, i_map_pos, i_map_end, i_rflank_start, i_rflank_end)
            b_flank=True
        elif (i_map_end>i_rflank_start) and (i_map_pos>i_rflank_start or abs(i_rflank_start-i_map_pos)<i_slack):
            print(algnmt.query_name, i_map_pos, i_map_end, i_rflank_start, i_rflank_end)
            b_flank=True

        if (n_lclip + n_rclip) < i_max_clip_len:
            return b_flank, True, n_lclip, n_rclip
        else:
            return b_flank, False, n_lclip, n_rclip

####
    ####save the non transduction inseriton events to a file
    ####each record in format:
    # ins_chrm, ins_pos, rep_type, structure_type, s_region1, s_region2, TSD, transduct_src, s_seq, transduct_seq
    ####i_del_slack: if the interval distance > i_del_slack, then view as an internal insertion
    def save_expn_ref_ins_info_to_file(self, l_succeed, i_del_slack, sf_out):
        with open(sf_out, "w") as fout_ins:
            lis = LInternalStructure()
            xpolyA=PolyA()
            for (ref_rep_copy_start, rcd) in l_succeed:
                s_rg1=rcd[4]#region1
                s_rg2=rcd[5]#region2

                (ins_chrm, ins_pos, rep_type, structure_type, s_region1, s_region2, s_TSD, transduct_src,
                 s_seq, transduct_seq)=rcd
                s_structure=lis.get_internal_structure(s_rg1, s_rg2, i_del_slack)
                s_with_polyA = self.chk_polyA(xpolyA, s_seq)
                # b_rpolyA=xpolyA.is_consecutive_polyA_T(seq[:10])
                # b_lpolyA=xpolyA.is_consecutive_polyA_T(seq[-10:])
                # if b_lpolyA or b_rpolyA:
                #     s_with_polyA="with_polyA"
                s_id = "{0}~{1}".format(ins_chrm, ins_pos)
                if s_id in self.m_tsd:
                    s_TSD=self.m_tsd[s_id]

                s_region1 = self.adjust_pos(s_region1, self.i_copy_flank_len)
                s_region2 = self.adjust_pos(s_region2, self.i_copy_flank_len)
                sinfo = ins_chrm + "\t" + str(ins_pos)+" "+str(
                    ref_rep_copy_start) + "\t" + rep_type + "\t" + s_structure + "\t" + s_region1 + "\t" + s_region2 \
                        + "\t" + s_TSD + "\t" + transduct_src + "\t" + transduct_src + "\t" + s_seq + "\t" + \
                        transduct_seq + "\t" + transduct_seq + "\t" + s_with_polyA + "\n"
                fout_ins.write(sinfo)

####
    ####save the non transduction inseriton events to a file
    ####each record in format:
    # ins_chrm, ins_pos, rep_type, structure_type, s_region1, s_region2, TSD, transduct_src, s_seq, transduct_seq
    ####i_del_slack: if the interval distance > i_del_slack, then view as an internal insertion
    def save_non_transduct_ins_info_to_file_sva(self, l_succeed, i_del_slack, sf_out, i_ofst=0):
        with open(sf_out, "w") as fout_ins:
            lis = LInternalStructure()
            xpolyA=PolyA()
            for rcd in l_succeed:
                s_rg1=rcd[4]#region1
                s_rg2=rcd[5]#region2

                (ins_chrm, ins_pos, rep_type, structure_type, s_region1, s_region2, s_TSD, transduct_src,
                 s_seq, transduct_seq)=rcd
                s_structure=lis.get_internal_structure(s_rg1, s_rg2, i_del_slack)
                s_with_polyA = self.chk_polyA(xpolyA, s_seq)
                # b_rpolyA=xpolyA.is_consecutive_polyA_T(seq[:10])
                # b_lpolyA=xpolyA.is_consecutive_polyA_T(seq[-10:])
                # if b_lpolyA or b_rpolyA:
                #     s_with_polyA="with_polyA"
                s_id = "{0}~{1}".format(ins_chrm, ins_pos)
                if s_id in self.m_tsd:
                    s_TSD=self.m_tsd[s_id]

                if len(s_seq)<global_values.LRD_MIN_INS_LTH:
                    continue
                if self.is_no_polA_no_TSD(s_with_polyA, s_TSD):
                    continue

                if i_ofst != 0:
                    s_region1 = self.adjust_pos(s_region1, i_ofst)
                    s_region2 = self.adjust_pos(s_region2, i_ofst)
                sinfo = ins_chrm + "\t" + str(
                    ins_pos) + "\t" + rep_type + "\t" + s_structure + "\t" + s_region1 + "\t" + s_region2 + "\t" + \
                        s_TSD + "\t" + transduct_src + "\t" + transduct_src + "\t" + s_seq + "\t" + transduct_seq + \
                        "\t" + transduct_seq + "\t" + s_with_polyA + "\n"
                fout_ins.write(sinfo)

####